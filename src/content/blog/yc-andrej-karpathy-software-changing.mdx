---
title:
  en: "Notes: Software Is Changing (Again)"
  zh: "笔记：软件正在（再次）改变"
description:
  en: "Andrej Karpathy's YC talk on the evolution of software from 1.0 to 3.0, LLMs as operating systems, and building for the AI era"
  zh: "Andrej Karpathy 在 YC 的演讲：软件从 1.0 到 3.0 的演变、LLM 作为操作系统，以及为 AI 时代构建产品"
date: 2025-06-19
tags: ["ycombinator", "ai", "andrej-karpathy", "software", "llm"]
image: "https://i2.ytimg.com/vi/LCEmiRjPEtQ/hqdefault.jpg"
---

import YouTube from '../../components/YouTube.astro';

<YouTube id="LCEmiRjPEtQ" title="Andrej Karpathy: Software Is Changing (Again)" />

:::en
This post summarizes Andrej Karpathy's talk at Y Combinator (June 2025) on how software is fundamentally changing in the AI era.

## The Three Paradigms of Software

Software hasn't changed much on a fundamental level for 70 years, but it has changed twice quite rapidly in the last few years.

### Software 1.0: Traditional Code
- Computer code written by humans (C++, Python, etc.)
- Instructions to the computer for carrying out tasks
- GitHub is the repository for this code

### Software 2.0: Neural Networks
- The weights of neural networks
- You don't write this code directly - you tune datasets and run optimizers
- Hugging Face is the "GitHub" of Software 2.0
- Example: Tesla Autopilot migrated functionality from C++ to neural networks over time

### Software 3.0: LLM Prompts
- Prompts are programs that program the LLM
- Remarkably, these prompts are written in English
- A completely new programming paradigm in our native language

The key insight: Neural networks became **programmable** with large language models. This is a new kind of computer.

## LLMs as Operating Systems

Andrew Ng said "AI is the new electricity," but Karpathy argues LLMs are more like **operating systems** than utilities:

**Why not just utilities?**
- LLMs aren't simple commodities like electricity
- They're increasingly complex software ecosystems
- The ecosystem mirrors OS development: closed-source providers (like Windows/Mac) and open-source alternatives (Llama as the potential "Linux")

**The OS analogy:**
- LLM = CPU equivalent
- Context window = Memory
- LLM orchestrates memory and compute for problem-solving
- Apps can run on different "operating systems" (GPT, Claude, Gemini)

**We're in the 1960s of computing:**
- LLM compute is still expensive
- Forces centralization in the cloud
- We're all thin clients using time-sharing
- Personal computing revolution hasn't happened yet (though Mac Minis show early signs)

## The Psychology of LLMs

LLMs are trained on humans, giving them emergent human-like psychology:

**Superpowers:**
- Encyclopedic knowledge and memory
- Can remember SHA hashes, phone books worth of data
- Like the autistic savant in "Rain Man"

**Cognitive deficits:**
- Hallucinations and confabulation
- Poor self-knowledge
- Jagged intelligence (superhuman in some areas, makes mistakes no human would make)
- Anterograde amnesia (can't learn and consolidate knowledge over time like a coworker would)

## Building LLM Apps

Successful LLM apps share common properties:

1. **Context management** - Package up information for the LLM
2. **Orchestrate multiple LLM calls** - Embedding models, chat models, diff models
3. **Application-specific GUI** - Text is hard to read and verify; GUIs allow humans to audit fallible systems faster
4. **Autonomy slider** - From tab completion to full agentic mode

**Examples:**
- **Cursor**: Tab completion (low autonomy) → Cmd+K (edit chunk) → Cmd+L (edit file) → Cmd+I (full repo agent)
- **Perplexity**: Quick search → Research → Deep research (10+ minutes)

## The Iron Man Suit Analogy

The Iron Man suit is both an **augmentation** (Tony Stark drives it) and an **agent** (can fly autonomously). This is the autonomy slider in action.

**Current recommendation:**
- Less Iron Man robots, more Iron Man suits
- Less flashy demos of autonomous agents, more partial autonomy products
- Build custom GUIs so the generation-verification loop is very fast
- Don't lose sight that full automation is possible - include an autonomy slider

## Vibe Coding

Karpathy coined "vibe coding" - a new way of programming:

> "There's a new kind of coding I call 'vibe coding' where you fully give in to the vibes, embrace exponentials, and forget that the code even exists."

**Key insight:** Everyone is now a programmer because everyone speaks natural language.

**Best practices for AI-assisted coding:**
- Work in small incremental chunks
- Spin the generation-verification loop very fast
- Be concrete in prompts (vague prompts → failed verification → spinning)
- Keep the AI "on the leash"

**The Menu Gen experience:**
- Vibe coding the app: few hours
- Making it real (auth, payments, deployment): a week
- The DevOps clicking-in-browser work was the hard part, not the code

## Building for Agents

There's a new category of consumer of digital information: **agents** (people spirits on the internet).

**The problem:** Human interfaces (GUIs) aren't designed for LLMs. Instructions like "go to this URL, click this dropdown" should be automated.

**Solutions:**
- **llms.txt**: Simple markdown telling LLMs what your domain is about
- **Git Ingest**: Change GitHub URL to get LLM-readable concatenated files
- **Deep Wiki**: AI-generated documentation for any repo

**Key principle:** Meet LLMs halfway. Make information accessible to them, even though they can technically click around - it's expensive and error-prone.

## Summary

What an amazing time to enter the industry:
- A ton of code needs to be written and rewritten
- LLMs are like utilities, fabs, but especially like operating systems
- It's the 1960s of operating systems - so much to invent
- LLMs are fallible "people spirits" we must learn to work with
- Adjust infrastructure towards them
- Build LLM apps with proper context management, orchestration, GUIs, and autonomy sliders
:::

:::zh
本文总结了 Andrej Karpathy 在 Y Combinator（2025年6月）关于 AI 时代软件如何根本性改变的演讲。

## 软件的三个范式

软件在基础层面上 70 年来没有太大变化，但在过去几年里已经快速改变了两次。

### 软件 1.0：传统代码
- 人类编写的计算机代码（C++、Python 等）
- 给计算机执行任务的指令
- GitHub 是这类代码的仓库

### 软件 2.0：神经网络
- 神经网络的权重
- 你不直接编写这些代码 - 你调整数据集并运行优化器
- Hugging Face 是软件 2.0 的"GitHub"
- 例子：特斯拉 Autopilot 随时间将功能从 C++ 迁移到神经网络

### 软件 3.0：LLM 提示词
- 提示词是编程 LLM 的程序
- 值得注意的是，这些提示词是用英语编写的
- 一种全新的、使用我们母语的编程范式

关键洞察：神经网络通过大语言模型变得**可编程**。这是一种新型计算机。

## LLM 作为操作系统

Andrew Ng 说"AI 是新的电力"，但 Karpathy 认为 LLM 更像**操作系统**而非公用事业：

**为什么不只是公用事业？**
- LLM 不是像电力那样的简单商品
- 它们是日益复杂的软件生态系统
- 生态系统反映了操作系统的发展：闭源提供商（如 Windows/Mac）和开源替代品（Llama 可能成为"Linux"）

**操作系统类比：**
- LLM = CPU 等价物
- 上下文窗口 = 内存
- LLM 协调内存和计算来解决问题
- 应用可以在不同"操作系统"上运行（GPT、Claude、Gemini）

**我们处于计算的 1960 年代：**
- LLM 计算仍然昂贵
- 迫使集中在云端
- 我们都是使用分时系统的瘦客户端
- 个人计算革命尚未发生（尽管 Mac Mini 显示出早期迹象）

## LLM 的心理学

LLM 在人类数据上训练，使它们具有涌现的类人心理：

**超能力：**
- 百科全书式的知识和记忆
- 能记住 SHA 哈希、电话簿级别的数据量
- 像电影《雨人》中的自闭症天才

**认知缺陷：**
- 幻觉和虚构
- 自我认知差
- 参差不齐的智能（某些领域超人，但会犯人类不会犯的错误）
- 顺行性遗忘（不能像同事那样随时间学习和巩固知识）

## 构建 LLM 应用

成功的 LLM 应用有共同特性：

1. **上下文管理** - 为 LLM 打包信息
2. **协调多个 LLM 调用** - 嵌入模型、聊天模型、差异模型
3. **应用特定的 GUI** - 文本难以阅读和验证；GUI 让人类更快地审核易出错的系统
4. **自主性滑块** - 从 Tab 补全到完全代理模式

**例子：**
- **Cursor**：Tab 补全（低自主性）→ Cmd+K（编辑代码块）→ Cmd+L（编辑文件）→ Cmd+I（整个仓库代理）
- **Perplexity**：快速搜索 → 研究 → 深度研究（10+ 分钟）

## 钢铁侠战衣类比

钢铁侠战衣既是**增强**（Tony Stark 驾驶它）也是**代理**（可以自主飞行）。这就是自主性滑块的实际应用。

**当前建议：**
- 少做钢铁侠机器人，多做钢铁侠战衣
- 少做自主代理的炫酷演示，多做部分自主的产品
- 构建自定义 GUI，让生成-验证循环非常快
- 不要忘记完全自动化是可能的 - 包含自主性滑块

## Vibe Coding

Karpathy 创造了"vibe coding"这个词 - 一种新的编程方式：

> "有一种新的编码方式我称之为'vibe coding'，你完全沉浸在氛围中，拥抱指数级增长，忘记代码的存在。"

**关键洞察：** 现在每个人都是程序员，因为每个人都会说自然语言。

**AI 辅助编码的最佳实践：**
- 以小的增量块工作
- 快速旋转生成-验证循环
- 提示词要具体（模糊的提示词 → 验证失败 → 原地打转）
- 让 AI "保持在控制之下"

**Menu Gen 的经历：**
- Vibe coding 应用：几小时
- 让它真正可用（认证、支付、部署）：一周
- 在浏览器中点击的 DevOps 工作是困难的部分，而不是代码

## 为代理构建

数字信息有了新的消费者类别：**代理**（互联网上的人类精神）。

**问题：** 人类界面（GUI）不是为 LLM 设计的。像"去这个 URL，点击这个下拉菜单"这样的指令应该被自动化。

**解决方案：**
- **llms.txt**：简单的 markdown，告诉 LLM 你的域名是关于什么的
- **Git Ingest**：更改 GitHub URL 以获取 LLM 可读的连接文件
- **Deep Wiki**：为任何仓库生成 AI 文档

**关键原则：** 与 LLM 相向而行。让信息对它们可访问，即使它们技术上可以到处点击 - 这很昂贵且容易出错。

## 总结

进入这个行业的绝佳时机：
- 大量代码需要编写和重写
- LLM 像公用事业、像晶圆厂，但尤其像操作系统
- 这是操作系统的 1960 年代 - 有太多东西要发明
- LLM 是我们必须学会合作的易出错的"人类精神"
- 调整基础设施以适应它们
- 构建具有适当上下文管理、协调、GUI 和自主性滑块的 LLM 应用
:::
