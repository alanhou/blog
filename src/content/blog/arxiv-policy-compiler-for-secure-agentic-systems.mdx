---
title:
  en: "PCAS: Policy Compiler for Secure Agentic Systems"
  zh: "PCAS:面向安全智能体系统的策略编译器"
description:
  en: "A deterministic policy enforcement framework for LLM-based agents that uses dependency graphs and Datalog-derived rules to achieve 93% compliance with zero violations."
  zh: "一个面向大语言模型智能体的确定性策略执行框架,通过依赖图和Datalog衍生规则实现93%合规率且零违规。"
date: 2026-02-19
tags: ["arxiv", "ai", "cs.cr", "cs.ai", "cs.ma"]
image: "https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png"
---

:::en
**Paper**: [2602.16708](https://arxiv.org/abs/2602.16708)
**Authors**: Nils Palumbo, Sarthak Choudhary, Jihye Choi, Prasad Chalasani, Mihai Christodorescu, Somesh Jha
**Categories**: cs.CR, cs.AI, cs.MA

## Abstract

As LLM-based agents are deployed in increasingly sensitive contexts—customer service, approval workflows, data access control, and regulatory compliance—the need for robust authorization mechanisms becomes critical. Traditional approaches that embed policies directly in prompts offer no enforcement guarantees, leaving systems vulnerable to policy violations through prompt manipulation or model reasoning failures. This paper introduces PCAS (Policy Compiler for Agentic Systems), a framework that provides deterministic policy enforcement for multi-agent systems through compile-time instrumentation and runtime monitoring.

PCAS addresses the fundamental challenge that linear message histories cannot capture complex information flows across agents. Instead, it models system state as a dependency graph that tracks causal relationships among events including tool calls, results, and inter-agent messages. Policies are expressed in a Datalog-derived declarative language that naturally handles transitive information flow and cross-agent provenance tracking. A reference monitor intercepts all actions before execution, blocking policy violations deterministically regardless of model behavior. Evaluated across three domains—prompt injection defense, pharmacovigilance workflows, and customer service—PCAS improves compliance from 48% to 93% with zero violations in instrumented runs.

## Key Contributions

- A dependency graph model for tracking information flow in multi-agent systems that captures causal relationships beyond linear message histories
- A Datalog-derived policy language for expressing complex authorization rules including transitive information flow and cross-agent provenance
- A compile-time instrumentation approach that transforms existing agent implementations into policy-compliant systems without security-specific restructuring
- A reference monitor architecture that provides deterministic policy enforcement independent of LLM reasoning capabilities
- Empirical validation across three case studies demonstrating 93% policy compliance with zero violations in instrumented systems

## Technical Architecture

PCAS operates through a three-stage pipeline: policy compilation, system instrumentation, and runtime enforcement.

The policy compilation stage translates high-level policy specifications into executable enforcement rules. Policies are written in a Datalog-derived language that extends traditional access control with information flow tracking. For example, a policy preventing customer data leakage might specify: `forbid(send_email(Agent, Recipient, Content)) :- contains_pii(Content), not authorized_recipient(Recipient)`. The compiler analyzes these rules to identify enforcement points and generates monitoring code.

System instrumentation wraps existing agent implementations with tracking and enforcement logic. PCAS intercepts three critical event types: tool invocations, tool results, and inter-agent messages. Each event is recorded in the dependency graph with edges representing information flow. When Agent A calls a tool that returns data subsequently used by Agent B, the graph captures this transitive dependency. The instrumentation is transparent to the original agent code—no manual security refactoring is required.

Runtime enforcement uses a reference monitor that evaluates policy rules against the current dependency graph before allowing actions to execute. When an agent attempts an action, the monitor queries the graph to determine if the action would violate any policy. For information flow policies, this involves checking whether sensitive data would reach unauthorized destinations through transitive paths. The monitor blocks violations deterministically, providing security guarantees independent of model behavior.

## Dependency Graph Model

The core innovation enabling PCAS is its dependency graph representation of system state. Traditional agent frameworks maintain linear conversation histories that lose critical information about causality and data provenance. PCAS constructs a directed acyclic graph where nodes represent events and edges represent information flow.

Three node types capture the essential events in agentic systems:
- Tool call nodes represent agent decisions to invoke external functions
- Tool result nodes capture the data returned by tool executions
- Message nodes represent communication between agents or with users

Edges in the graph encode how information flows between events. When an agent makes a tool call, an edge connects from the agent's context to the call node. When the tool returns results, an edge connects to a result node. If those results inform a subsequent message or tool call, additional edges capture that dependency. This structure naturally represents transitive information flow: if data from source $S$ influences event $E_1$, which influences $E_2$, the graph contains a path $S \rightarrow E_1 \rightarrow E_2$.

The graph model enables sophisticated policy queries. To determine if an action would leak sensitive data, the monitor performs a reachability analysis: does a path exist from a sensitive data source to the proposed action? For approval workflows, the monitor checks whether required authorization events appear as ancestors of the proposed action in the graph. This graph-based reasoning handles complex scenarios that would be difficult or impossible to express with linear history inspection.

## Evaluation Results

PCAS was evaluated across three case studies representing different policy enforcement challenges: information flow control for prompt injection defense, approval workflows in pharmacovigilance, and organizational policies for customer service.

In the prompt injection defense scenario, policies prevent agents from executing commands derived from untrusted user input. Without PCAS, frontier models (GPT-4, Claude) exhibited 48% policy compliance—they frequently executed injected commands despite prompt-based warnings. With PCAS instrumentation, compliance reached 93% with zero policy violations in the subset of runs where the agent attempted policy-violating actions. The remaining 7% represented cases where agents failed to complete tasks for reasons unrelated to policy enforcement.

The pharmacovigilance case study involved a multi-agent system processing adverse drug event reports. Policies required supervisor approval before submitting reports to regulatory authorities. Baseline agents bypassed approval workflows 35% of the time, either through reasoning failures or prompt manipulation. PCAS enforcement achieved 100% compliance—no reports were submitted without proper authorization chains visible in the dependency graph.

Customer service evaluation tested organizational policies like "don't offer refunds exceeding $X without manager approval" and "don't access customer data from other regions." Across 200 test scenarios with varying complexity, uninstrumented agents violated policies in 52% of cases. PCAS-instrumented systems achieved 93% compliance with zero violations in runs where policy-relevant actions were attempted. The 7% gap represented task failures unrelated to security.

## Implications and Future Directions

PCAS demonstrates that deterministic policy enforcement for agentic systems is achievable without sacrificing the flexibility that makes LLM-based agents valuable. The compile-time instrumentation approach means developers can build agents using familiar frameworks and patterns, then add security as a separate concern through policy specification.

The dependency graph model has implications beyond security. It provides a foundation for explainability—showing users why an action was blocked by tracing information flow through the graph. It enables auditing by maintaining a complete provenance record of how decisions were made. It could support debugging by helping developers understand unexpected agent behavior through causal analysis.

Several directions for future work emerge. The current policy language, while expressive, could be extended with temporal operators for policies involving time-based constraints. The system could be optimized for lower overhead through incremental graph updates rather than full recomputation. Integration with formal verification tools could provide static guarantees about policy properties before deployment.

The evaluation also reveals limitations. PCAS cannot prevent all security issues—it enforces specified policies but cannot detect unspecified vulnerabilities. Policy specification requires security expertise, though the declarative language is more accessible than imperative security code. The system adds runtime overhead, though measurements show this is acceptable for most applications (typically &lt;100ms per action).

## Takeaways

1. Embedding authorization policies in prompts provides no enforcement guarantees—LLMs can fail to follow instructions through reasoning errors or prompt manipulation
2. Dependency graphs capture information flow in multi-agent systems more accurately than linear message histories, enabling sophisticated policy queries about transitive data flow
3. Datalog-derived policy languages provide a natural fit for expressing authorization rules that account for provenance and information flow across agents
4. Compile-time instrumentation allows adding deterministic policy enforcement to existing agent implementations without security-specific restructuring
5. Reference monitor architectures can provide security guarantees independent of LLM behavior by intercepting and validating actions before execution
6. Empirical results show PCAS improves policy compliance from 48% to 93% across frontier models with zero violations in instrumented runs
7. The approach generalizes across diverse policy types including information flow control, approval workflows, and organizational access restrictions
:::

:::zh
**论文**: [2602.16708](https://arxiv.org/abs/2602.16708)
**作者**: Nils Palumbo, Sarthak Choudhary, Jihye Choi, Prasad Chalasani, Mihai Christodorescu, Somesh Jha
**分类**: cs.CR, cs.AI, cs.MA

## 摘要

随着基于大语言模型的智能体被部署到越来越敏感的场景中——客户服务、审批工作流、数据访问控制和监管合规——对强健授权机制的需求变得至关重要。将策略直接嵌入提示词的传统方法无法提供执行保证,使系统容易因提示词操纵或模型推理失败而违反策略。本文介绍了PCAS(智能体系统策略编译器),这是一个通过编译时插桩和运行时监控为多智能体系统提供确定性策略执行的框架。

PCAS解决了线性消息历史无法捕获跨智能体复杂信息流的根本挑战。相反,它将系统状态建模为依赖图,跟踪事件之间的因果关系,包括工具调用、结果和智能体间消息。策略用Datalog衍生的声明式语言表达,自然地处理传递性信息流和跨智能体溯源跟踪。引用监视器在执行前拦截所有操作,无论模型行为如何都能确定性地阻止策略违规。在三个领域的评估中——提示词注入防御、药物警戒工作流和客户服务——PCAS将合规率从48%提升到93%,插桩运行中零违规。

## 主要贡献

- 用于跟踪多智能体系统信息流的依赖图模型,捕获超越线性消息历史的因果关系
- 用于表达复杂授权规则的Datalog衍生策略语言,包括传递性信息流和跨智能体溯源
- 编译时插桩方法,将现有智能体实现转换为策略合规系统,无需安全特定的重构
- 引用监视器架构,提供独立于大语言模型推理能力的确定性策略执行
- 跨三个案例研究的实证验证,展示93%策略合规率且插桩系统零违规

## 技术架构

PCAS通过三阶段流水线运作:策略编译、系统插桩和运行时执行。

策略编译阶段将高级策略规范转换为可执行的执行规则。策略用Datalog衍生语言编写,该语言扩展了传统访问控制以支持信息流跟踪。例如,防止客户数据泄露的策略可能指定:`forbid(send_email(Agent, Recipient, Content)) :- contains_pii(Content), not authorized_recipient(Recipient)`。编译器分析这些规则以识别执行点并生成监控代码。

系统插桩用跟踪和执行逻辑包装现有智能体实现。PCAS拦截三种关键事件类型:工具调用、工具结果和智能体间消息。每个事件都记录在依赖图中,边表示信息流。当智能体A调用返回数据的工具,该数据随后被智能体B使用时,图捕获这种传递依赖。插桩对原始智能体代码透明——不需要手动安全重构。

运行时执行使用引用监视器,在允许操作执行前根据当前依赖图评估策略规则。当智能体尝试操作时,监视器查询图以确定该操作是否会违反任何策略。对于信息流策略,这涉及检查敏感数据是否会通过传递路径到达未授权目的地。监视器确定性地阻止违规,提供独立于模型行为的安全保证。

## 依赖图模型

使PCAS成为可能的核心创新是其系统状态的依赖图表示。传统智能体框架维护线性对话历史,丢失了关于因果关系和数据溯源的关键信息。PCAS构建有向无环图,其中节点表示事件,边表示信息流。

三种节点类型捕获智能体系统中的基本事件:
- 工具调用节点表示智能体调用外部函数的决策
- 工具结果节点捕获工具执行返回的数据
- 消息节点表示智能体之间或与用户的通信

图中的边编码信息如何在事件之间流动。当智能体进行工具调用时,边从智能体上下文连接到调用节点。当工具返回结果时,边连接到结果节点。如果这些结果影响后续消息或工具调用,额外的边捕获该依赖关系。这种结构自然地表示传递性信息流:如果来自源$S$的数据影响事件$E_1$,而$E_1$影响$E_2$,则图包含路径$S \rightarrow E_1 \rightarrow E_2$。

图模型支持复杂的策略查询。要确定操作是否会泄露敏感数据,监视器执行可达性分析:是否存在从敏感数据源到提议操作的路径?对于审批工作流,监视器检查所需授权事件是否作为图中提议操作的祖先出现。这种基于图的推理处理用线性历史检查难以或不可能表达的复杂场景。

## 评估结果

PCAS在三个案例研究中进行评估,代表不同的策略执行挑战:提示词注入防御的信息流控制、药物警戒中的审批工作流以及客户服务的组织策略。

在提示词注入防御场景中,策略防止智能体执行源自不可信用户输入的命令。没有PCAS时,前沿模型(GPT-4、Claude)表现出48%的策略合规率——尽管有基于提示词的警告,它们经常执行注入的命令。使用PCAS插桩后,合规率达到93%,在智能体尝试违反策略操作的运行子集中零策略违规。剩余7%代表智能体因与策略执行无关的原因未能完成任务的情况。

药物警戒案例研究涉及处理药物不良事件报告的多智能体系统。策略要求在向监管机构提交报告前获得主管批准。基线智能体35%的时间绕过审批工作流,要么通过推理失败,要么通过提示词操纵。PCAS执行实现100%合规——没有报告在依赖图中没有适当授权链的情况下提交。

客户服务评估测试了组织策略,如"未经经理批准不提供超过$X的退款"和"不访问其他地区的客户数据"。在200个不同复杂度的测试场景中,未插桩智能体在52%的情况下违反策略。PCAS插桩系统实现93%合规率,在尝试策略相关操作的运行中零违规。7%的差距代表与安全无关的任务失败。

## 影响与未来方向

PCAS证明了智能体系统的确定性策略执行是可实现的,而不会牺牲使基于大语言模型的智能体有价值的灵活性。编译时插桩方法意味着开发者可以使用熟悉的框架和模式构建智能体,然后通过策略规范将安全作为独立关注点添加。

依赖图模型的影响超越了安全性。它为可解释性提供了基础——通过追踪图中的信息流向用户展示为什么操作被阻止。它通过维护决策如何做出的完整溯源记录来支持审计。它可以通过因果分析帮助开发者理解意外的智能体行为来支持调试。

出现了几个未来工作方向。当前策略语言虽然表达力强,但可以用时间算子扩展以支持涉及时间约束的策略。系统可以通过增量图更新而非完全重新计算来优化以降低开销。与形式化验证工具的集成可以在部署前提供关于策略属性的静态保证。

评估也揭示了局限性。PCAS无法防止所有安全问题——它执行指定的策略但无法检测未指定的漏洞。策略规范需要安全专业知识,尽管声明式语言比命令式安全代码更易访问。系统增加了运行时开销,尽管测量显示这对大多数应用是可接受的(通常每个操作&lt;100ms)。

## 要点总结

1. 将授权策略嵌入提示词无法提供执行保证——大语言模型可能因推理错误或提示词操纵而未能遵循指令
2. 依赖图比线性消息历史更准确地捕获多智能体系统中的信息流,支持关于传递数据流的复杂策略查询
3. Datalog衍生的策略语言自然适合表达考虑跨智能体溯源和信息流的授权规则
4. 编译时插桩允许向现有智能体实现添加确定性策略执行,无需安全特定的重构
5. 引用监视器架构可以通过在执行前拦截和验证操作来提供独立于大语言模型行为的安全保证
6. 实证结果显示PCAS将前沿模型的策略合规率从48%提升到93%,插桩运行中零违规
7. 该方法在不同策略类型中通用,包括信息流控制、审批工作流和组织访问限制
:::
